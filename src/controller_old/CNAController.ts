// import { dbOperations } from '../database/db-operations';
// import { RESPONSE_ERROR_MESSAGE, CVE_STATUS } from '../constants';
// import { CveObject } from './utils/CVE_Object_Class';
// export class CNAController {
//     /**
//   * @api {post} /get-cve-info Get CVE Info
//   * @apiName Get CVE Info
//   * @apiGroup CVE
//   * @apiVersion  0.0.0
//   * @apiDescription 
//   * Use this method to get status and/or the related metadata about the CVEs that have been allocated to the requestor. 
//   * Information can be requested for a single CVE ID, all CVE IDs, a subset of CVE IDs as specified by a filter.
//   * Note: Caller must be authenticated, authorized CVE AIS user.
//   * 
//   * @apiHeader Signature RSA Signature.
//   * @apiParamExample {json} Request-Example With ID's:
//  content-type: application/json
//  {
//    "Payload": {
//      "ids": ["CVE-2019-10d2b65c-c68e-4804-b444-45e6b172e708"]
//    }, 
//    "userUUID": "246aef24-c31e-485e-ab03-133fa0cc3442"
//  }
 
//  * @apiParamExample {json} Request-Example with Status Filter:
//  content-type: application/json
//  {
//    "Payload": {
//      "filter": 'Free|Rejected|Disputed|Populated|Published|Public|Reserved|Obsolete'
//    }, 
//    "userUUID": "246aef24-c31e-485e-ab03-133fa0cc3442"
//  }
 
//   *@apiSuccessExample Success-Response For ID's Search:
//   *HTTP/1.1 200 OK
//  [
//      {
//          "cve_id": "CVE-2019-10d2b65c-c68e-4804-b444-45e6b172e708",
//          "status": "status",
//          "Requestor": {
//              "user_id": "246aef24-c31e-485e-ab03-133fa0cc3442",
//              "user_name": "user name"
//          },
//          "Organization": {
//              "org_id": "3bb4c1e8-84fd-466a-bc32-b39a5ba5df4a",
//              "org_name": "Org Name"
//          },
//          "History": "TBD"
//      }
//  ]
//   *@apiSuccessExample Success-Response For Filters Search:
//   *HTTP/1.1 200 OK
//  [
//      {
//          "cve_id": "CVE-2019-10d2b65c-c68e-4804-b444-45e6b172e708",
//          "status": "Free|Rejected|Disputed|Populated|Published|Public|Reserved|Obsolete",
//          "Requestor": {
//              "user_id": "246aef24-c31e-485e-ab03-133fa0cc3442",
//              "user_name": "user name"
//          },
//          "Organization": {
//              "org_id": "3bb4c1e8-84fd-466a-bc32-b39a5ba5df4a",
//              "org_name": "Org Name"
//          },
//          "History": "TBD"
//      }
//  ]
//   * @apiErrorExample Error-Response 1:
//   *HTTP/1.1 400 Bad Request
//  {
//    "error": "error message"
//  }
//   * @apiErrorExample Error-Response 2:
//   *HTTP/1.1 500 Bad Request
//  {
//    "error": "Failed to validate key."
//  }
//   */

//     public async getCveInfo(request, response, next) {
//         const { payload } = request.body;
//         var filterFlag = false;
//         var result = [];
//         var cveIdObject = {
//             cve_id: '',
//             status: '',
//             Organization: { org_id: '', org_name: '' },
//             History: 'TBD',
//         };
//         try {
//             if (payload.filter) {
//                 if (!CVE_STATUS[payload.filter]) {
//                     response.status(403).json({ error: RESPONSE_ERROR_MESSAGE[403] });
//                 } else {
//                     filterFlag = true;
//                 }
//             }
//             if (payload.ids) {
//                 var holdResponse = [];
//                 for (var i = 0; i < payload.ids.length; i++) {
//                     try {
//                         let cves = await dbOperations.getCveByID(payload.ids[i], request.cnaData.cnaUUID);
//                         holdResponse.push(cves);
//                     } catch (err) {
//                         console.log(err);
//                         response.status(403).json({ error: RESPONSE_ERROR_MESSAGE[403] });
//                     }
//                 }
//                 for (var i = 0; i < holdResponse.length; i++) {
//                     cveIdObject.cve_id = holdResponse[i][0].cveID;
//                     cveIdObject.status = holdResponse[i][0].cveStatus;
//                     cveIdObject.Organization.org_id = holdResponse[i][0].cveOrganizationUUID;
//                     cveIdObject.Organization.org_name = holdResponse[i][0].cveOragnizationName;
//                     result.push(cveIdObject);
//                 }
//                 response.status(200).json(result);
//             } else {
//                 if (filterFlag) {
//                     dbOperations
//                         .getAllOrgCvesFilter(request.cnaData.cnaUUID, payload.filter)
//                         .then(
//                             resolved => {
//                                 for (var i = 0; i < resolved.length; i++) {
//                                     cveIdObject.cve_id = resolved[i].cveID;
//                                     cveIdObject.status = resolved[i].cveStatus;
//                                     cveIdObject.Organization.org_name = resolved[i].cveOragnizationName;
//                                     cveIdObject.Organization.org_id = resolved[i].cveOrganizationUUID;
//                                     result.push(cveIdObject);
//                                 }
//                                 response.status(200).json(result);
//                             },
//                             rejected => {
//                                 response.status(400).json(RESPONSE_ERROR_MESSAGE[400]);
//                             },
//                         )
//                         .catch(err => {
//                             console.log(err);
//                             response.status(400).json({ error: RESPONSE_ERROR_MESSAGE[400] });
//                         });
//                 } else {
//                     dbOperations
//                         .getAllOrgCvesNoFilter(request.cnaData.cnaUUID)
//                         .then(
//                             resolved => {
//                                 for (var i = 0; i < resolved.length; i++) {
//                                     cveIdObject.cve_id = resolved[i].cveID;
//                                     cveIdObject.status = resolved[i].cveStatus;
//                                     cveIdObject.Organization.org_name = resolved[i].cveOragnizationName;
//                                     cveIdObject.Organization.org_id = resolved[i].cveOrganizationUUID;
//                                     result.push(cveIdObject);
//                                 }
//                                 response.status(200).json(result);
//                             },
//                             rejected => {
//                                 response.status(400).json(RESPONSE_ERROR_MESSAGE[400]);
//                             },
//                         )
//                         .catch(err => {
//                             console.log(err);
//                             response.status(400).json({ error: RESPONSE_ERROR_MESSAGE[400] });
//                         });
//                 }
//             }
//         } catch (err) {
//             console.log(err);
//             response.status(400).json({ error: RESPONSE_ERROR_MESSAGE[400] });
//         }
//     }

//     /**
// * @api {post} /get-cve-id Request CVE ID
// * @apiName Request CVE ID
// * @apiGroup CVE
// * @apiVersion  0.0.0
// * @apiDescription 
// * This method will allocate and assign one or more non-sequential CVE IDs to the requestor. The backend database will be 
// * updated to reflect the allocated CVE IDs, status (i.e. "Reserved"), and requestors identity & associated CNA (as provided by 
// * the CVE Authentication and Authorization Services).

// * Note: the number of CVE IDs are limited based on the specified quota.

// * Note: the params are optional. If no params are given, default CVE object will be handed out. 
// * @apiHeader Signature RSA Signature.
// * @apiParamExample {json} Request-Example With ID's:
// content-type: application/json
// {
//  "payload":
//  {
//    "year" : "2009", 
//    "count" : 1, 
//    "status": "Free"
//  }, 
//  "userUUID": "246aef24-c31e-485e-ab03-133fa0cc3442"
// }


// *@apiSuccessExample Success-Response For ID's Search:
// *HTTP/1.1 200 OK
// [
//   {
//        "cve_id": "CVE-2009-74007fad-fe80-4770-a5b3-7e47a5093122",
//        "status": "Free",
//        "Requestor": {
//            "user_id": "246aef24-c31e-485e-ab03-133fa0cc3442",
//            "user_name": "User Name"
//        },
//        "Organization": {
//            "org_id": "3bb4c1e8-84fd-466a-bc32-b39a5ba5df4a",
//            "org_name": "Org Name "
//        },
//        "History": "TBD"
//    }
// ]

// * @apiErrorExample Error-Response 1:
// *HTTP/1.1 400 Bad Request
// {
//  "error": "Invalid Year"
// }
// * @apiErrorExample Error-Response 2:
// *HTTP/1.1 500 Bad Request
// {
//  "error": "Invalid Status"
// }
// */
//     public async getCveId(request, response, next) {
//         const { payload } = request.body;
//         if (!payload.year) {
//             payload.year = undefined;
//         }
//         if (!payload.status) {
//             payload.status = undefined;
//         }
//         if (!payload.count) {
//             payload.count = 1;
//         }
//         try {
//             var result = [];
//             for (var i = 0; i < payload.count; i++) {
//                 try {
//                     var newCveID = new CveObject(request, payload.year, payload.status);
//                     var cveID = newCveID.createCVEID();
//                     result.push(cveID);
//                 } catch (e) {
//                     console.log(e);
//                     response.status(403).json({ error: RESPONSE_ERROR_MESSAGE[403] });
//                 }
//                 try {
//                     await dbOperations.saveCVE(cveID);
//                 } catch (e) {
//                     console.log(e);
//                     response.status(400).json({ error: RESPONSE_ERROR_MESSAGE[400] });
//                 }
//             }
//             response.status(200).json(result);
//         } catch (e) {
//             response.status(400).json({ error: RESPONSE_ERROR_MESSAGE[400] });
//         }
//     }

//     /**
// * @api {post} /set-cve-status Set CVE ID Status
// * @apiName Set CVE ID Status
// * @apiGroup CVE
// * @apiVersion  0.0.0
// * @apiDescription 
// * Use this method to update the status of assigned CVE IDs in the backend database.
 
// * @apiHeader Signature RSA Signature.
// * @apiParamExample {json} Request-Example With ID's:
// content-type: application/json
// {
// "payload":
// {
// "ids":["CVE-2009-b5c29a6c-c7e2-4e2d-9680-e16d612d9e3f", "CVE-2009-9b30ace9-7ccc-4d15-8590-3c329279b7e4"],
// "status": "Free|Rejected|Disputed|Populated|Published|Public|Reserved|Obsolete"
// }, 
// "userUUID": "246aef24-c31e-485e-ab03-133fa0cc3442"
// }


// *@apiSuccessExample Success-Response For ID's Search:
// *HTTP/1.1 200 OK
// {
//   "Success": true
// }

// * @apiErrorExample Error-Response:
// *HTTP/1.1 400 Bad Request
// {
// "error": "Invalid Status"
// }

// */
//     public async setCveIdStatus(request, response, next) {
//         const { payload } = request.body;
//         try {
//             if (payload.status) {
//                 if (!CVE_STATUS[payload.status]) {
//                     response.status(403).json({ error: RESPONSE_ERROR_MESSAGE[403] });
//                 }
//             }

//             var result = [];
//             for (let i = 0; i < payload.ids.length; i++) {
//                 try {
//                     let newStatus = await dbOperations.editCveStatus(
//                         payload.ids[i],
//                         payload.status,
//                         request.cnaData.cnaUUID,
//                     );
//                     result.push(newStatus);
//                 } catch (err) {
//                     response.status(400).json({ error: RESPONSE_ERROR_MESSAGE[400] });
//                 }
//             }
//             if (response === 1) {
//                 response.status(200).json({ Success: true });
//             } else {
//                 response.status(400).json({ error: RESPONSE_ERROR_MESSAGE[501] });
//             }
//         } catch (err) {
//             console.log(err);
//             response.status(400).json({ error: RESPONSE_ERROR_MESSAGE[400] });
//         }
//     }
// }
