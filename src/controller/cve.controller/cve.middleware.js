const { validationResult } = require('express-validator')
const errors = require('./error')
const error = new errors.CveControllerError()
const utils = require('../../utils/utils')
const fs = require('fs')
const RejectedSchema = JSON.parse(fs.readFileSync('src/middleware/Reject_5.0_Schema.json'))
const cnaContainerSchema = JSON.parse(fs.readFileSync('src/controller/cve.controller/cna_container_schema.json'))
const logger = require('../../middleware/logger')
const Ajv = require('ajv')
const addFormats = require('ajv-formats')
const ajv = new Ajv({ allErrors: true })
addFormats(ajv)
const validateRejected = ajv.compile(RejectedSchema)
const validateCnaContainer = ajv.compile(cnaContainerSchema)

function parsePostParams (req, res, next) {
  utils.reqCtxMapping(req, 'body', [])
  utils.reqCtxMapping(req, 'params', ['id'])
  next()
}

function parseGetParams (req, res, next) {
  utils.reqCtxMapping(req, 'query', ['page', 'time_modified.lt', 'time_modified.gt', 'state', 'count_only', 'assignerShortName', 'assigner'])
  utils.reqCtxMapping(req, 'params', ['id'])
  next()
}

// Sanitizer for dates
function toDate (val) {
  let value = val.match(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?(|Z|((-|\+|\s)\d{2}:\d{2}))$/)
  let result
  if (value) {
    value[0] = value[0].replace(' ', '+') // Re-add literal '+' which was stripped
    result = new Date(value[0])
  } else {
    value = val.match(/^\d{4}-\d{2}-\d{2}$/)
    if (value) {
      result = new Date(`${value[0]}T00:00:00.000+00:00`)
    } else {
      result = null
    }
  }
  return result
}

function parseError (req, res, next) {
  const err = validationResult(req).formatWith(({ location, msg, param, value, nestedErrors }) => {
    return { msg: msg, param: param, location: location }
  })
  if (!err.isEmpty()) {
    return res.status(400).json(error.badInput(err.array()))
  }
  next()
}

function uniqueEnglishDescription (rejectedReasonsArr) {
  const langArray = rejectedReasonsArr.map(function (reason) { return reason.lang.toLowerCase() })// create arr of lowercase lang values
  const foundValues = new Set() // set to hold languages found
  // loop through the lang array and find duplicates
  for (var i = 0; i < langArray.length; i++) {
    if (langArray[i].startsWith('en')) { // check case only if lang starts with "en"
      if (foundValues.has(langArray[i])) {
        return false // duplicate found so return false
      }
      foundValues.add(langArray[i]) // add each unique value to set
    }
  }
  return true // if no duplicate found, then all lang values were unique
}

function validateRejectBody (req, res, next) {
  const rejectBody = req.body
  const result = validateRejected(rejectBody) // validate function is based on custom schema

  if (!result) {
    const temp = validateRejected.errors
    const errors = []
    temp.forEach((error) => {
      if (error !== '') {
        errors.push(error)
      }
    })
    return res.status(400).json(error.invalidJsonSchema(errors))
  }
  next()
}

function validateCveCnaContainerJsonSchema (req, res, next) {
  const cnaContainer = req.body
  const result = validateCnaContainer(cnaContainer)
  if (!result) {
    logger.error(JSON.stringify({ uuid: req.ctx.uuid, message: 'CVE JSON schema validation FAILED.' }))
    const temp = validateCnaContainer.errors
    const errorsArray = []
    temp.forEach((error) => {
      if (error !== '') {
        errorsArray.push(error)
      }
    })
    return res.status(400).json(error.invalidCnaContainerJsonSchema(errorsArray))
  }
  logger.info(JSON.stringify({ uuid: req.ctx.uuid, message: 'SUCCESSFUL CVE JSON schema validation.' }))
  next()
}

module.exports = {
  parseGetParams,
  parsePostParams,
  parseError,
  toDate,
  validateCveCnaContainerJsonSchema,
  uniqueEnglishDescription,
  validateRejectBody
}
