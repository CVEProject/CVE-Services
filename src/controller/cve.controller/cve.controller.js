const Cve = require('../../model/cve')
const axios = require('axios')
const logger = require('../../middleware/logger')

// INFO: DO NOT USE - Not integrated with CPS
// TODO: Pagination
async function getAllCves (req, res) {
  try {
    const result = await axios.get('')

    // CPS work item was approved
    if (!result.data.Error) {
      logger.info('The CVEs were sent to the user.')
      return res.status(200).json(result.data) // send CVEs to user
    } else {
      logger.warn('The CPS work item was not approved. The CVEs were not sent to the user.')
      logger.info(result.data.Error)
      return res.status(400).json({ message: 'A problem ocurred. The CVEs could not be fetched.' }) // send error message to user
    }
  } catch (err) {
    logger.error(err.stack)
    return res.status(500).send('Internal Server Error') // send error message to user
  }
}

// TODO: Request parameter validation
// Gets a CVE for the specified CVE ID
async function getCve (req, res) {
  const cveId = req.params.id
  const instance = axios.create({
    timeout: 10000,
    headers: {
      'CVE-API-CNA': req.header('CVE-API-CNA'),
      'CVE-API-SUBMITTER': req.header('CVE-API-SUBMITTER'),
      'CVE-API-SECRET': req.header('CVE-API-SECRET')
    }
  })

  try {
    const result = await instance.get('https://cvecps-dev.mitre.org/cps/ws/cve/' + cveId)

    // CPS work item was approved
    if (!result.data.Error) {
      logger.info(cveId + ' was sent to the user.')
      return res.status(200).json(result.data) // send CVE to user
    } else {
      logger.warn('The CPS work item was not approved. ' + cveId + ' was not sent to the user.')
      logger.info(result.data.Error)
      return res.status(400).json({ message: 'A problem ocurred. ' + cveId + ' could not be fetched.' }) // send error message to user
    }
  } catch (err) {
    logger.error(err.stack)
    return res.status(500).send('Internal Server Error') // send error message to user
  }
}

// TODO: Request body sanitation
// CPS: Updates a CVE if one exists for the specified CVE ID in the request body
// MongoDB: Creates a new CVE only if it does not exists for the specified CVE ID in the request body. If it exists, it does not update the CVE.
async function submitCve (req, res) {
  const cve = req.body
  const cveId = cve.CVE_data_meta.ID
  const instance = axios.create({
    timeout: 10000,
    headers: {
      'CVE-API-CNA': req.header('CVE-API-CNA'),
      'CVE-API-SUBMITTER': req.header('CVE-API-SUBMITTER'),
      'CVE-API-SECRET': req.header('CVE-API-SECRET')
    }
  })

  try {
    const cpsResult = await instance.post('https://cvecps-dev.mitre.org/cps/ws/cve/' + cveId + '/', cve)

    // CPS work item was approved
    if (!cpsResult.data.Error) {
      logger.info(cveId + ' has been created/updated in CPS.')
      logger.info(cpsResult.data.Message)

      // Find CVE in MongoDB
      Cve.findOne()
        .byCveId(cveId)
        .exec((err, result) => {
          if (err) {
            logger.warn('An error ocurred in MongoDB. ' + cveId + ' was not found in the database.')
            logger.error(err.stack)
          }

          // Create CVE in MongoDB if it doesn't exist
          if (!result) {
            const newCve = new Cve({ cve: JSON.parse(cpsResult.data.Entry) })

            // Find and Update CVE in MongoDB
            Cve.findOneAndReplace()
              .byCveId(cveId)
              .replaceOne(newCve)
              .setOptions({ upsert: true })
              .exec((err) => {
                if (err) {
                  logger.warn('An error ocurred in MongoDB. ' + cveId + ' was not created in the database.')
                  logger.error(err.stack)
                }

                logger.info(cveId + ' was successfully created in MongoDB.')
              })
          } else {
            logger.info(cveId + ' was not created in MongoDB because it already exists.')
          }

          // Respond to the user always
          return res.status(200).json({ message: cveId + ' has been created.' }) // send message to user
        })

      // Find CVE in MongoDB
      // Cve.findOne()
      //   .byCveId(cveId)
      //   .exec((err, result) => {
      //     if (err) {
      //       logger.warn('An error ocurred in MongoDB. ' + cveId + ' was not found in the database.')
      //       logger.error(err.stack)
      //     }

      //     // Create CVE in MongoDB if it doesn't exist
      //     if (!result) {
      //       const newCve = new Cve({ cve: JSON.parse(cpsResult.data.Entry) })

      //       Cve.create(newCve, (err) => {
      //         if (err) {
      //           logger.warn('An error ocurred in MongoDB. ' + cveId + ' was not created in the database.')
      //           logger.error(err.stack)
      //         } else {
      //           logger.info(cveId + ' was successfully created in MongoDB.')
      //         }
      //       })
      //     } else {
      //       logger.info(cveId + ' was not created because it already exists.')
      //     }

      //     // Respond to the user always
      //     return res.status(200).json({ message: cveId + ' has been created' }) // send message to user
      //   })
    } else {
      logger.warn('The CPS work item was not approved. ' + cveId + ' was not created.')
      logger.warn(cpsResult.data.Error)
      return res.status(400).json({ message: 'The CPS work item was not approved. ' + cveId + ' could not be created.' }) // send error message to user
    }
  } catch (err) {
    // Request to CPS failed
    logger.error(err.stack)
    return res.status(500).send('Internal Server Error') // send error message to user
  }
}

// TODO: Request body sanitation and parameter validation
// CPS: Updates a CVE if one exists for the specified CVE ID
// MongoDB: Updates a CVE only if it exists. If no CVE exists, it does not create the CVE.
async function updateCve (req, res) {
  const cve = req.body
  const cveId = req.params.id
  const instance = axios.create({
    timeout: 10000,
    headers: {
      'CVE-API-CNA': req.header('CVE-API-CNA'),
      'CVE-API-SUBMITTER': req.header('CVE-API-SUBMITTER'),
      'CVE-API-SECRET': req.header('CVE-API-SECRET')
    }
  })

  if (cveId !== cve.CVE_data_meta.ID) {
    return res.status(400).json({ message: cveId + ' parameter does not match ' + cve.CVE_data_meta.ID + ' in the JSON body.' })
  }

  try {
    const cpsResult = await instance.post('https://cvecps-dev.mitre.org/cps/ws/cve/' + cveId + '/', cve)

    // CPS work item was approved
    if (!cpsResult.data.Error) {
      logger.info(cveId + ' has been updated in CPS.')
      logger.info(cpsResult.data.Message)

      const newCve = new Cve({ cve: JSON.parse(cpsResult.data.Entry), _id: false })

      // Find and Update CVE in MongoDB
      Cve.findOneAndReplace()
        .byCveId(cveId)
        .replaceOne(newCve)
        .exec((err, result) => {
          if (err) {
            logger.warn('An error ocurred in MongoDB. ' + cveId + ' was not updated in the database.')
            logger.error(err.stack)
          } else {
            if (result.n === 0) {
              logger.info(cveId + ' was not updated in MongoDB because it does not exists in the database.')
            } else {
              logger.info(cveId + ' was successfully updated in MongoDB.')
            }
          }

          // Respond to the user always
          return res.status(200).json({ message: cveId + ' has been updated.' }) // send message to user
        })
    } else {
      logger.warn('The CPS work item was not approved. ' + cveId + ' was not updated.')
      logger.warn(cpsResult.data.Error)
      return res.status(400).json({ message: 'The CPS work item was not approved. ' + cveId + ' could not be updated.' }) // send error message to user
    }
  } catch (err) {
    // Request to CPS failed
    logger.error(err.stack)
    return res.status(500).send('Internal Server Error') // send error message to user
  }

  // res.status(200).json({ message: cveId + ' has been updated' })
}

module.exports = {
  CVE_LIST_ALL: getAllCves,
  CVE_SINGLE: getCve,
  CVE_SUBMIT: submitCve,
  CVE_UPDATE_SINGLE: updateCve
}
