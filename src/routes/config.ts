import 'reflect-metadata';
import { Application } from 'express';
import { buildSchema, AuthChecker } from 'type-graphql';
import * as graphqlHTTP from 'express-graphql';
import * as expressPlayground from 'graphql-playground-middleware-express';
import { OrganizationResolver } from '../database/graphql/resolvers/organization.resolver';
import { DevResolver } from '../database/graphql/resolvers/dev.resolver';
import { getRepository } from 'typeorm';
import { Organizations } from '../database/entities/organization.entity';
import { AdminResolver } from '../database/graphql/resolvers/admin.resolver';
import { verifySignature } from './controllers/utils/rsa';
import { CNANumberingAuthority } from '../database/entities/cna.entity';
import { CNAResolver } from '../database/graphql/resolvers/cna.resolver';
import { GraphQLSchema } from 'graphql';
const admin_endpoints: string[] = ['changeOrgStatus'];
const organization_endpoints: string[] = ['listOrganizationCNAS', 'addCNA'];
const cna_endpoints: string[] = ['submitCVE'];

export async function configureRoutes(app: Application) {
    // graphql endpoint
    if (process.env.NODE_ENV === 'development') {
        app.use(
            '/playground',
            expressPlayground.default({
                endpoint: '/graphql',
            })
        );
    }
    const importSchema = await createSchema();
    app.use(
        '/graphql',
        graphqlHTTP(req => ({
            schema: importSchema,
            graphiql: process.env.NODE_ENV === 'development',
            context: req,
        }))
    );
}

/**
 * Creates a reusaable Graphql Schema
 */
export async function createSchema(): Promise<GraphQLSchema> {
    const schema = await buildSchema({
        resolvers: [OrganizationResolver, DevResolver, AdminResolver, CNAResolver],
        authChecker: customAuthChecker,
    });

    return schema;
}

/**
 * Works as middle ware for different Graphql endpoints marled with  @Authorized()
 * Routes must be placed in the admin_endpoints/organization_endpoints/cna_endpoints string arrays
 */

export const customAuthChecker: AuthChecker = async ({ root, args, context, info }) => {
    for (const restricted of admin_endpoints) {
        if (info.fieldName.search(restricted) === 0) {
            console.log(`verifying admin endpoint ${restricted}`);
            let organization = getRepository(Organizations);
            let org = await organization.findOne({ relations: ['admin', 'publicKey'], where: { organizationUUID: args.data.adminOrganizationUUID } });
            if (org === undefined) {
                return false;
            }
            if (org.admin.adminUUID) {
                const signatureVerification = verifySignature(args.data.organizationUUID, args.data.signature, org.publicKey.publicKey);
                if (signatureVerification) {
                    return true;
                }
                return false;
            } else {
                return false;
            }
        }
    }

    for (const restricted of organization_endpoints) {
        if (info.fieldName.search(restricted) === 0) {
            console.log(`verifying organization endpoint ${restricted}`);
            let organization = getRepository(Organizations);
            let org = await organization.findOne({ relations: ['admin', 'publicKey'], where: { organizationUUID: args.data.organizationUUID } });
            if (org === undefined) {
                return false;
            }
            if (org) {
                const signatureVerification = verifySignature(args.data.organizationUUID, args.data.signature, org.publicKey.publicKey);
                if (signatureVerification) {
                    return true;
                }
                return false;
            } else {
                return false;
            }
        }
    }

    for (const restricted of cna_endpoints) {
        if (info.fieldName.search(restricted) === 0) {
            console.log(`verifying cna endpoint ${restricted}`);
            let cnaRepository = getRepository(CNANumberingAuthority);
            let cna = await cnaRepository.findOne({ relations: ['organization', 'organization.publicKey'], where: { cnaUUID: args.data.cnaUUID } });
            if (cna === undefined) {
                return false;
            }
            if (cna) {
                const signatureVerification = verifySignature(args.data.cnaUUID, args.data.signature, cna.organization.publicKey.publicKey);
                if (signatureVerification) {
                    return true;
                }
                return false;
            } else {
                return false;
            }
        }
    }
};
