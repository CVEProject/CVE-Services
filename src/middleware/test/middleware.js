const User = require('../../model/user')
const cveSchema = require('../jsonSchema')
const Validator = require('jsonschema').Validator
const v = new Validator()
const uuidAPIKey = require('uuid-apikey')

const validateUser = (req) => {
  const cna = req.header['CVE-API-CNA']
  const submitter = req.header['CVE-API-SUBMITTER']
  const secret = req.header['CVE-API-SECRET']

  if (cna === undefined) {
    return { status: 400, message: 'Bad Request: CVE-API-CNA header field required.' }
  }

  if (submitter === undefined) {
    return { status: 400, message: 'Bad Request: CVE-API-SUBMITTER header field required.' }
  }

  if (secret === undefined) {
    return { status: 400, message: 'Bad Request: CVE-API-SECRET header field required.' }
  }

  const res = User.findOne()
    .byUserNameAndCnaShortName(submitter, cna)
    .exec((err, result) => {
      if (err) {
        return { status: 500, message: 'Internal Server Error' }
      }

      console.log('result: ', result)

      if (!result) {
        return { status: 401, message: 'Unauthorized' }
      }

      if (uuidAPIKey.toAPIKey(result.secret) !== secret) {
        return { status: 401, message: 'Unauthorized' }
      }

      return { status: 200, message: 'SUCCESSFUL user authentication for ' + submitter }
    })

  return res

  // return new Promise(() => {
  //   User.findOne()
  //     .byUserNameAndCnaShortName(submitter, cna)
  //     .exec((err, result) => {
  //       if (err) {
  //         return { status: 500, message: 'Internal Server Error' }
  //       }

  //       console.log('result: ', result)

  //       if (!result) {
  //         return { status: 401, message: 'Unauthorized' }
  //       }

  //       if (uuidAPIKey.toAPIKey(result.secret) !== secret) {
  //         return { status: 401, message: 'Unauthorized' }
  //       }

  //       return { status: 200, message: 'SUCCESSFUL user authentication for ' + submitter }
  //     })
  // })
}

// TODO: Request body sanitation, better user messages, and use correct status codes
const validateCveJsonSchema = (req) => {
  if (req.method === 'POST') {
    const cve = req.body
    const cveState = cve.CVE_data_meta.STATE
    let schema

    // For validating schema 5.0
    if (cveState === 'PUBLIC') {
      schema = cveSchema.publicSchema
      v.addSchema(schema, '/https://www.first.org/cvss/cvss-v3.1.json?20190610')
      v.addSchema(schema, '/https://www.first.org/cvss/cvss-v3.0.json?20170531')
      v.addSchema(schema, '/https://www.first.org/cvss/cvss-v2.0.json?20170531')
    } else if (cveState === 'RESERVED') {
      schema = cveSchema.reservedSchema
    } else if (cveState === 'REJECT') {
      schema = cveSchema.rejectSchema
    } else {
      return { status: 400, message: 'CVE JSON schema validation FAILED.', errors: ['instance.CVE_data_meta.STATE is not one of enum values'] }
    }

    const result = v.validate(cve, schema, { nestedErrors: true })

    if (result.valid) {
      return { status: 200, message: 'SUCCESSFUL CVE JSON schema validation.' }
    } else {
      const temp = result.toString().split('\n')
      const errors = []
      temp.forEach((error) => {
        if (error !== '') {
          const array = error.split(':', 2)
          errors.push(array[1].trim())
        }
      })

      return { status: 400, message: 'CVE JSON schema validation FAILED.', errors: errors }
    }
  } else if (req.method === 'GET') {
    return { status: 200 }
  } else {
    return { status: 400, message: 'Bad Request' }
  }
}

module.exports = {
  validateUser,
  validateCveJsonSchema
}
