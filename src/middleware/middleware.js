const CONSTANTS = require('../constants')
const Org = require('../model/org')
const User = require('../model/user')
const cveSchema = require('./jsonSchema')
const logger = require('./logger')
const Validator = require('jsonschema').Validator
const v = new Validator()
const uuidAPIKey = require('uuid-apikey')
const uuid = require('uuid')
const utils = require('../utils/utils')

const validateUser = (req, res, next) => {
  const org = req.ctx.header.org
  const user = req.ctx.header.user
  const key = req.ctx.header.key

  logger.info(JSON.stringify({ uuid: req.ctx.uuid, action: 'validating auth headers', org: org }))

  User.findOne()
    .byUserNameAndCnaShortName(user, org)
    .exec((err, result) => {
      if (err) {
        var response = { error: 'SERVICE_FAILURE', message: 'The API cannot process this request at this time.' }
        logger.info(JSON.stringify({ uuid: req.ctx.uuid, action: 'internal server error upon authentication', org: org, response: response }))
        logger.error(err.stack)
        return res.status(500).json(response)
      }
      var unauthres = { error: 'Unauthorized', message: 'Unauthorized' }
      if (!result) {
        logger.info(JSON.stringify({ uuid: req.ctx.uuid, action: 'user not found', org: org, response: unauthres }))
        return res.status(401).json(unauthres)
      }

      if (!result.active) {
        logger.info(JSON.stringify({ uuid: req.ctx.uuid, action: 'user deactivated', org: org, user: result.UUID, response: unauthres }))
        return res.status(401).json(unauthres)
      }

      if (uuidAPIKey.toAPIKey(result.secret) !== key) {
        logger.info(JSON.stringify({ uuid: req.ctx.uuid, action: 'user provided wrong key', org: org, user: result.UUID, response: unauthres }))
        return res.status(401).json(unauthres)
      }

      logger.info(JSON.stringify({ uuid: req.ctx.uuid, action: 'user authenticated', org: org, user: result.UUID }))
      next()
    })
}

async function onlySecretariat (req, res, next) {
  const org = req.ctx.header.org
  const isSec = await utils.isSecretariat(org)
  if (!isSec) {
    logger.info(JSON.stringify({ uuid: req.ctx.uuid, action: 'org is not a secretariat', org: org, response: CONSTANTS.SECRETARIAT_ONLY }))
    return res.status(403).json(CONSTANTS.SECRETARIAT_ONLY)
  }
  logger.info(JSON.stringify({ uuid: req.ctx.uuid, action: 'confirmed org as secretariat', org: org }))
  next()
}

async function onlyCnas (req, res, next) {
  const shortName = req.header(CONSTANTS.AUTH_HEADERS.ORG)
  const org = await Org.findOne().byShortName(shortName)

  if (org.authority.active_roles.includes(CONSTANTS.AUTH_ROLE_ENUM.SECRETARIAT)) {
    logger.info({ message: org + ' is a ' + CONSTANTS.AUTH_ROLE_ENUM.SECRETARIAT + ' so until Root CNAs are implemented this role is allowed.' })
    next()
  } else if (org.authority.active_roles.includes(CONSTANTS.AUTH_ROLE_ENUM.CNA)) {
    // the org is a CNA
    logger.info({ message: 'Confirmed ' + org + ' as a ' + CONSTANTS.AUTH_ROLE_ENUM.CNA })
    next()
  } else {
    logger.info({ message: org + ' is NOT a ' + CONSTANTS.AUTH_ROLE_ENUM.CNA })
    return res.status(403).json(CONSTANTS.CNA_ONLY)
  }
}

var createCtxAndReqUUID = function (req, res, next) {
  req.ctx = {}
  req.ctx.uuid = uuid.v4()
  logger.info(JSON.stringify({ uuid: req.ctx.uuid, path: req.path }))
  next()
}

var ctxHeaders = function (req, res, next) {
  if (req.path !== '/health-check') {
    var org = req.header(CONSTANTS.AUTH_HEADERS.ORG)
    var user = req.header(CONSTANTS.AUTH_HEADERS.USER)
    var key = req.header(CONSTANTS.AUTH_HEADERS.KEY)

    if (org === undefined) {
      return res.status(400).json({ error: 'MISSING_HEADER', message: CONSTANTS.AUTH_HEADERS.ORG + ' header field required.' })
    }

    if (user === undefined) {
      return res.status(400).json({ error: 'MISSING_HEADER', message: CONSTANTS.AUTH_HEADERS.USER + ' header field required.' })
    }

    if (key === undefined) {
      return res.status(400).json({ error: 'MISSING_HEADER', message: CONSTANTS.AUTH_HEADERS.KEY + ' header field required.' })
    }

    req.ctx.header = {org: org, user: user, key: key}
  }
  next()
}

// TODO: Request body sanitation, better user messages, and use correct status codes
const validateCveJsonSchema = (req, res, next) => {
  if (req.method.toUpperCase() === 'POST') {
    const cve = req.body
    const cveState = cve.CVE_data_meta.STATE
    let schema
    logger.info('Validating CVE JSON schema.')

    // For validating schema 4.0
    // if (cveState === 'PUBLIC' || cveState === 'RESERVED' || cveState === 'REJECT') {
    //   schema = cveSchema.cveSchema4
    // } else {
    //   return res.status(400).json({ message: 'CVE JSON schema validation FAILED.', errors: ['instance.CVE_data_meta.STATE is not one of enum values'] })
    // }

    // For validating schema 5.0
    if (cveState === 'PUBLIC') {
      schema = cveSchema.publicSchema
      v.addSchema(schema, '/https://www.first.org/cvss/cvss-v3.1.json?20190610')
      v.addSchema(schema, '/https://www.first.org/cvss/cvss-v3.0.json?20170531')
      v.addSchema(schema, '/https://www.first.org/cvss/cvss-v2.0.json?20170531')
    } else if (cveState === 'RESERVED') {
      schema = cveSchema.reservedSchema
    } else if (cveState === 'REJECT') {
      schema = cveSchema.rejectSchema
    } else {
      return res.status(400).json({ message: 'CVE JSON schema validation FAILED.', errors: ['instance.CVE_data_meta.STATE is not one of enum values'] })
    }

    const result = v.validate(cve, schema, { nestedErrors: true })

    if (result.valid) {
      logger.info('SUCCESSFUL CVE JSON schema validation.')
      next()
    } else {
      logger.error(result)
      logger.error('CVE JSON schema validation FAILED.')

      const temp = result.toString().split('\n')
      const errors = []
      temp.forEach((error) => {
        if (error !== '') {
          const array = error.split(':', 2)
          errors.push(array[1].trim())
        }
      })

      return res.status(400).json({ message: 'CVE JSON schema validation FAILED.', errors: errors })
    }
  } else {
    return res.status(400).send('Bad Request')
  }
}

module.exports = {
  validateUser,
  onlySecretariat,
  onlyCnas,
  createCtxAndReqUUID,
  ctxHeaders,
  validateCveJsonSchema
}
