# Using Docker with cve-services

## Security Considerations

The cve-services docker container contains a MongoDB instance that doesn't require authentication. If this container is exposed to the public internet it may allow unauthorised actors to modify data stored in the database.

## Setup for Local Development

Use the following steps to build and run cve-services (Node.js app
and Mongo) in docker containers.  Note that the current configurations
are set to run the services in development or staging (testing instance) mode. Note that these commands
must be run from the `docker/` directory.

The docker setup uses an environment defined in `docker/.docker-env.example`
but `docker-compose` looks for this file at `docker/.docker-env`.  The
`docker/.docker-env` file is ignored by our `.gitignore`. This is a
safeguard against developers committing changes to their local docker
environment.

## Setup for Local Penetration Testing

1. Change to the "staging" branch (this branch is used for the public testing instance):
  `git checkout staging`

<<<<<<< Updated upstream
2. Create your environment file if it doesn't already exist:
  `cp .docker-env.staging-example .docker-env`

3. Run the containers (this will also build the cveawg container from the included Dockerfile):
  `docker-compose up`

4. Populate mongoDB with test data included in "datadump/pre-population/":
  `docker-compose exec cveawg npm run populate:stage`

5. Retrieve an API Key (secret) for a test user that is stored in "user-secret.txt"
  `docker-compose exec cveawg cat user-secret.txt | grep admin2` \
  Should return: {"username":"admin2@mitre.org","secret":"API_KEY"}
=======
```
LOCAL_KEY=XXXXXXX-XXXXXXX-XXXXXXX-XXXXXXX
NODE_ENV=development
```

When using a development environment, the `LOCAL_KEY` is the API token key for the secretariat. In integration environments, the API keys will be written to a file named `user-secrets.txt` in the project directory.

### Start Docker Containers

```bash
cd docker/
git switch <branchname>
# use the integration environment
cp .docker-env.int-example .docker-env
docker compose up --build
```

>**Note**
>
> Use branch name `int` for penetration testing, and `dev` for local development.

Docker will build or update the containers if needed. In a few minutes, you should see something similar to the following:

```
[+] Running 3/3
 ⠿ Network docker_cve-services  Created
 ⠿ Container mongo              Created
 ⠿ Container cveawg             Created
Attaching to cveawg, mongo
mongo   | 2022-06-07T19:29:07.594+0000 I CONTROL  [initandlisten] MongoDB starting : pid=1 port=27017 dbpath=/data/db 64-bit host=551bb45dbadc
...
mongo   | 2022-06-07T19:29:08.106+0000 I NETWORK  [initandlisten] listening via socket bound to 0.0.0.0
mongo   | 2022-06-07T19:29:08.106+0000 I NETWORK  [initandlisten] listening via socket bound to /tmp/mongodb-27017.sock
mongo   | 2022-06-07T19:29:08.106+0000 I NETWORK  [initandlisten] waiting for connections on port 27017
...
cveawg  | > cve-services@0.0.3 start:dev /app
cveawg  | > node src/swagger.js && NODE_ENV=development node src/scripts/updateOpenapiHost.js && NODE_ENV=development node-dev src/index.js
...
cveawg  | 2022-06-07 19:29:10 [info]: "Using NODE_ENV 'development' and app environment 'development'"
cveawg  | 2022-06-07 19:29:11 [info]: "Using dbName = cve_dev"
...
cveawg  | 2022-06-07 19:29:11 [info]: "Successfully connected to database!"
cveawg  | 2022-06-07 19:29:11 [info]: "Serving on port 3000"
```

### Pre-load Data

Populate mongoDB with test data included in `datadump/pre-population/`

Run the command below using `populate:dev` or `populate:int` depending on your environment:
```
docker-compose exec cveawg npm run populate:int
```

You should see the following:
```
> cve-services@0.0.3 populate:dev /app
> NODE_ENV=development node-dev src/scripts/populate.js

2022-06-07 19:58:32 [info]: "Using NODE_ENV 'development' and app environment 'development'"
2022-06-07 19:58:32 [info]: "Using dbName = cve_dev"
2022-06-07 19:58:32 [info]: "Will try to connect to database cve_dev at docdb:27017"
2022-06-07 19:58:32 [info]: "Successfully connected to database!"
Are you sure you wish to pre-populate the database for the development environment? Doing so will drop the Cve, Cve-Id-Range, Cve-Id, User, Org collection(s) in the cve_dev database. (y/n) y

2022-06-07 19:58:37 [info]: "Populating Org collection..."
2022-06-07 19:58:37 [info]: "Org populated!"
2022-06-07 19:58:37 [info]: "Populating User collection..."
2022-06-07 19:58:38 [info]: "User populated!"
2022-06-07 19:58:38 [info]: "Populating Cve-Id-Range collection..."
2022-06-07 19:58:38 [info]: "Populating Cve collection..."
2022-06-07 19:58:38 [info]: "Populating Cve-Id collection..."
2022-06-07 19:58:38 [info]: "Cve-Id-Range populated!"
2022-06-07 19:58:38 [info]: "Cve populated!"
2022-06-07 19:58:39 [info]: "Cve-Id populated!"
2022-06-07 19:58:39 [info]: "Successfully populated the database!"
>>>>>>> Stashed changes

6. Before running curl commands to test the API, you can create a configuration file with the values of HTTP headers. The examples below require a configuration file. (If you do not wish to create a configuration file, then you can instead modify each example so that all headers are entered separately on the command line, e.g., `-H "CVE-API-ORG: mitre" -H "CVE-API-USER: admin2@mitre.org"` (etc.). Such a command line has an https://cwe.mitre.org/data/definitions/214.html weakness.) If you are using Bash on Linux, then you can type the following (except replace aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa with the correct 36-character API Key from step 5):
```
export CURL_CVE_CONFIG=$HOME/.curl-cve-config
touch $CURL_CVE_CONFIG
chmod 600 $CURL_CVE_CONFIG
/bin/echo -H \"CVE-API-ORG: mitre\" >> $CURL_CVE_CONFIG
/bin/echo -H \"CVE-API-USER: admin2@mitre.org\" >> $CURL_CVE_CONFIG
/bin/echo -H \"CVE-API-KEY: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\" >> $CURL_CVE_CONFIG
/bin/echo -H \"Content-type: application/json\" >> $CURL_CVE_CONFIG
/bin/echo -s >> $CURL_CVE_CONFIG
/bin/echo -S >> $CURL_CVE_CONFIG
```

<<<<<<< Updated upstream
7. Use curl to test the API's ability to show CVE IDs that exist in the running CVE Services:
  `curl -K $CURL_CVE_CONFIG http://localhost:3000/api/cve-id`

## Try It Out Further

   Use curl to retrieve organization information:
  `curl -K $CURL_CVE_CONFIG http://localhost:3000/api/org`
=======
See the [API documentation](https://github.com/CVEProject/cve-services#api-documentation) for available endpoints.

  * Show CVE IDs:
  `curl -K ~/.curl-cve-config http://localhost:3000/api/cve-id`

  * Retrieve organization info (Secretariat only. Use appropriate credentials in curl config file):
  `curl -K ~/.curl-cve-config http://localhost:3000/api/org`

  * Add a CNA (Secretariat only. Use appropriate credentials in curl config file):
    `curl -K ~/.curl-cve-config -X POST \
      --data-binary '{"name": "Example Corporation","short_name": "exampleCorp"}' \
      http://localhost:3000/api/org`
>>>>>>> Stashed changes

## To use curl to add a CNA

  `curl -K $CURL_CVE_CONFIG -X POST \
     --data-binary '{"name": "Example Corporation","short_name": "exampleCorp"}' \
     http://localhost:3000/api/org`

## To shell into the web app server

<<<<<<< Updated upstream
  `docker-compose exec cveawg /bin/sh`

## Using Mongo Express

You can use [Mongo Express](https://github.com/mongo-express/mongo-express)
(a mongo web UI) to view mongo from your browser.
To start Mongo Express you can start it with the following command:

  `docker run --network docker_cve-services -e ME_CONFIG_MONGODB_SERVER=docdb -p 8081:8081 mongo-express`

You can use Mongo Express to view the Mongo data by using the
following URL and viewing the *cve_dev or cve_stage* databases:

  <http://localhost:8081/>
=======
  `docker compose exec cveawg /bin/sh`

## Mongo DB

The `docker-compose.yml` file exposes the default Mongo port to the host: `localhost:27017`. You can connect using any Mongo viewer like [Mongo Express](https://github.com/mongo-express/mongo-express) or [Compass](https://www.mongodb.com/try/download/compass) on the host.
>>>>>>> Stashed changes
